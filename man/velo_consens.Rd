% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/velo_consens.R
\name{velo_consens}
\alias{velo_consens}
\title{Implement consensus velocity for inference of a single gene}
\usage{
velo_consens(
  u.obs,
  s.obs,
  state_inits,
  empirical = list(),
  mcmc = list(),
  epsilon = 0.001,
  n_chains = NULL,
  n_cores = NULL,
  cluster_type = "FORK",
  verbose = TRUE
)
}
\arguments{
\item{u.obs}{a vector of observed unspliced counts.}

\item{s.obs}{a vector of observed spliced counts.}

\item{state_inits}{a matrix of initial values for the state. Each column corresponds to one set of initial values, with rows corresponding to cells.
Can use the output from \code{generate_k}.}

\item{empirical}{output from \code{get_empirical}.}

\item{mcmc}{a list of mcmc setup: :
\itemize{
 \item \code{prep_niter} number of iterations in the preparation step where the state is fixed.
 \item \code{prep_burn_in} number of iterations to discard as burn-in in the preparation step.
 \item \code{prep_thinning} after burn-in in the preparation step, save the sample at every \code{thinning} iterations.
 \item \code{comp_niter} number of iterations in the full algorithm.
 \item \code{comp_burn_in} number of iterations to discard as burn-in in the full algorithm.
 \item \code{comp_thinning} after burn-in in the full algorithm, save the sample at every \code{thinning} iterations.
}}

\item{epsilon}{a small positive value used to compute empirical \eqn{\tau}. Better to use the same value as used in \code{get_empirical}.}

\item{n_chains}{number of chains to run. Default to run the same number as the provided \code{state_inits}.}

\item{n_cores}{number of cores used for parallel computing.}

\item{cluster_type}{see \code{makeCluster} for parallel computing.}

\item{verbose}{if TRUE, print the running time for the preparation step and complete algorithm for the first chain.}
}
\value{
The output is a list of results for all chains. Within each list, it contains the following components for each chain:
\item{output_index}{total number of saved MCMC samples, taking into account of burn-in and thinning.}
\item{k_output}{a list of vectors for sampled states. The list is of length \code{output_index}.}
\item{p_output}{a vector of sampled hyper-parameters \eqn{p}. The vector is of length \code{output_index}.}
\item{alpha1_1_output}{a vector of sampled rates \eqn{\alpha_1^{(1)}}. The vector is of length \code{output_index}.}
\item{gamma_output}{samples for rates \eqn{\gamma}. Similar to \code{alpha1_1_output}.}
\item{tau_output}{samples for local time \eqn{\tau}. Similar to \code{k_output}.}
\item{t0_output}{samples for switching point \eqn{t_0^{(2)}}.}
\item{lambda_output}{samples for \eqn{\lambda}.}
\item{u01_output}{samples for initial condition \eqn{u_0^{(1)}}.}
\item{sigma_u_2_output, sigma_s_2_output}{samples for variance parameters for unspliced and spliced counts.}
\item{mu_tau_output}{a list of vectors for sampled hyper-parameters \eqn{\mu_{\tau,j}} for \eqn{j=1,2}. The list is of length \code{output_index}.}
\item{var_tau_output}{samples for hyper-parameters \eqn{\sigma^2_{\tau,j}} for \eqn{j=1,2}. Similar to \code{mu_tau_output}.}
\item{mus_output}{a list of length \code{output_index}. Each element of the list is a list of two vectors saving samples of \eqn{u(t), s(t)} from the ODE.}
\item{acceptance_count_avg}{average acceptance probabilities over iterations for parameters drawn using adaptive Metroplis-Hastings.}
\item{log_like, log_post}{log-likelihood and log-posterior at each iteration (ignoring burnin and thinning).}
\item{mu_alpha, sig_alpha}{prior mean and standard deviation for \eqn{\alpha_1^{(1)}}.}
\item{mu_gamma, sig_gamma}{prior mean and standard deviation for \eqn{\gamma}.}
\item{mu_star_base, sig_star_base}{prior mean and standard deviation for \eqn{\mu_{\tau,j}} for \eqn{j=1,2}.}
\item{eta_base, nu_base}{prior mean and standard deviation for \eqn{\sigma^2_{\tau,j}} for \eqn{j=1,2}.}
\item{mu_0, var_0}{prior mean and variance for \eqn{t_0^{(2)}}.}
\item{lambda_lower, lambda_upper}{the lower and upper bound in the Uniform prior for \eqn{\lambda}.}
\item{u01_lower, u01_upper}{the lower and upper bound in the Uniform prior for \eqn{u_0^{(1)}}.}
\item{sigma_u_2_hat, sigma_s_2_hat, invgamma_f}{prior parameters in the inverse-gamma prior for variance parameters.}
}
\description{
The function runs multiple chains in parallel to infer unknown parameters for a single gene,
including a preparation step to find good initial values where states are fixed to empirical values.
}
\examples{
mcmc_list <- list(prep_niter = 1000, prep_burn_in = 500, prep_thinning = 1,
    comp_niter = 1000, comp_burn_in = 500, comp_thinning = 1)
set.seed(1)
consensus_result <- velo_consens(u.obs = u.obs, s.obs = s.obs, state_inits = k.inits,
   empirical = empirical, mcmc = mcmc_list, epsilon = 1e-3, n_cores = 3, n_chains = 10)
}
